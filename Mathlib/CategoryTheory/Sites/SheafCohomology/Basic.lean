/-
Copyright (c) 2024 Jo√´l Riou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jo√´l Riou
-/
import Mathlib.Algebra.Category.Grp.Abelian
import Mathlib.Algebra.Category.Grp.Adjunctions
import Mathlib.Algebra.Homology.DerivedCategory.Ext.Basic
import Mathlib.AlgebraicTopology.AlternatingFaceMapComplex
import Mathlib.AlgebraicTopology.CechNerve
import Mathlib.CategoryTheory.Sites.Abelian
import Mathlib.CategoryTheory.Sites.ConstantSheaf

/-!
# Sheaf cohomology

Let `C` be a category equipped with a Grothendieck topology `J`.
We define the cohomology types `Sheaf.H F n` of an abelian
sheaf `F` on the site `(C, J)` for all `n : ‚Ñï`. These abelian
groups are defined as the `Ext`-groups from the constant abelian
sheaf with values `‚Ñ§` (actually `ULift ‚Ñ§`) to `F`.

We also define `Sheaf.cohomologyPresheaf F n : C·µí·µñ ‚•§ AddCommGrp`
which is the presheaf which sends `U` to the `n`th `Ext`-group
from the free abelian sheaf generated by the presheaf
of sets `yoneda.obj U` to `F`.

## TODO
* if `U` is a terminal object of `C`, define an isomorphism
`(F.cohomologyPresheaf n).obj (Opposite.op U) ‚âÉ+ Sheaf.H F n`.
* if `U : C`, define an isomorphism
`(F.cohomologyPresheaf n).obj (Opposite.op U) ‚âÉ+ Sheaf.H (F.over U) n`.

-/

assert_not_exists TwoSidedIdeal

universe w' w v u

namespace CategoryTheory

open Abelian

variable {C : Type u} [Category.{v} C] {J : GrothendieckTopology C}

namespace Sheaf

section

variable (F : Sheaf J AddCommGrp.{w})
  [HasSheafify J AddCommGrp.{w}] [HasExt.{w'} (Sheaf J AddCommGrp.{w})]

/-- The cohomology of an abelian sheaf in degree `n`. -/
def H (n : ‚Ñï) : Type w' :=
  Ext ((constantSheaf J AddCommGrp.{w}).obj (AddCommGrp.of (ULift ‚Ñ§))) F n

noncomputable instance (n : ‚Ñï) : AddCommGroup (F.H n) := by
  dsimp only [H]
  infer_instance

end

section

variable [HasSheafify J AddCommGrp.{v}] [HasExt.{w'} (Sheaf J AddCommGrp.{v})]

variable (J) in
/-- The bifunctor which sends an abelian sheaf `F` and an object `U` to the
`n`th Ext-group from the free abelian sheaf generated by the
presheaf of sets `yoneda.obj U` to `F`. -/
noncomputable def cohomologyPresheafFunctor (n : ‚Ñï) :
    Sheaf J AddCommGrp.{v} ‚•§ C·µí·µñ ‚•§ AddCommGrp.{w'} :=
  Functor.flip
    (Functor.op (yoneda ‚ãô (whiskeringRight _ _ _).obj
      AddCommGrp.free ‚ãô presheafToSheaf _ _) ‚ãô extFunctor n)

/-- Given an abelian sheaf `F`, this is the presheaf which sends `U`
to the `n`th Ext-group from the free abelian sheaf generated by the
presheaf of sets `yoneda.obj U` to `F`. -/
noncomputable abbrev cohomologyPresheaf (F : Sheaf J AddCommGrp.{v}) (n : ‚Ñï) :
    C·µí·µñ ‚•§ AddCommGrp.{w'} :=
  (cohomologyPresheafFunctor J n).obj F

end


open Limits

def toCocompletion (F : C·µí·µñ ‚•§ AddCommGrp.{u}) : (C·µí·µñ ‚•§ Type v)·µí·µñ ‚•§ AddCommGrp.{v} where
  obj X := limit sorry /- I tried to come up with something like, take limit of a diagram where
    every map `V ‚ü∂ U` corresponds to a new map `F(U) ‚ü∂ F(V)`, and something like, take
    `X(U)` copies of `U`, but couldn't really make it work. -/
  map f := sorry

noncomputable def sieveToCocompletion (X : C) (ùí∞ : J X) : C·µí·µñ ‚•§ Type v where
  obj y := ùí∞.val.arrows (Y := y.unop)
  map f g := ‚ü®f.unop ‚â´ g.1, ùí∞.val.downward_closed _ f.unop‚ü©

noncomputable def sieveToCocompletionArrow (X : C) (ùí∞ : J X) : Arrow (C·µí·µñ ‚•§ Type v) where
  left := sieveToCocompletion X ùí∞
  right := yoneda.obj X
  hom := { app y f := f.1 }

def Cech.complex (F : Sheaf J AddCommGrp.{v}) (X : C) (ùí∞ : J X) : CochainComplex AddCommGrp ‚Ñï :=
  (AlgebraicTopology.alternatingCofaceMapComplex _).obj <|
    Functor.rightOp (Arrow.cechNerve <| sieveToCocompletionArrow X ùí∞) ‚ãô
      (toCocompletion F.val) -- I should use one universe?

end Sheaf

end CategoryTheory
